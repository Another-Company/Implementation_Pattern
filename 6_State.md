

6. 상태(State)
- 객체는 외부에 드러나는 행위와 행위를 지원하기 위한 상태를 묶어주는 편리한 단위다
- 객체 사용의 장점은 프로그램에 있는 모든 상태를 잘게 쪼개서 적당한 곳에 저장할 수 있다는 것이다
- 객체를 사용하면 참조할 수 있는 상태의 네임스페이스가 훨씬 작아지므로, 특정 변화에 의해 상태가 어떤 영향을 받을지 분석하기 쉽다

- 상태
    - 시간에 따라 변화하는 값을 사용하여 연산한다
    - 효과적으로 상태를 관리하기 위한 키포인트는 유사한 상태를 묶어서 관리하고 각 상태를 별도록 관리 하는 것이다
      두개의 상태가 동일한 연산안에서 사용되고, 동일한 시점에 생성되고 소멸되는지 보면 된다
      함께 사용되고 생성 소멸 시점이 동일한 두 가지 상태를 밀접하게 관리하는 것은 좋은 아이디어일 가능성이 높다

- 접근
    - 상태에 대한 접근을 제한해서 유연성을 조절한다
    - 하나의 프로그래밍 언어는 저장된 값에 대한 접근과 계산으로 나눌 수 있다
    - 따라서 자장과 계산의 경계를 명확하게 하는 것이 좋다
    - 접근의 용이성을 위해 객체 간의 독립성을 포기하는 것은 바람직하지 않다

- 직접 접근
    - 객체 내의 상태를 직접 접근한다
    - 데이터를 가져오거나 저장하는 것을 나타내는 가장 간단한 방법은 직접 변수를 접근하는 것이다
        - ex) x = 10;
    - 표현의 명확성이 장점이다 -> 유연성이 희생된다
    - 프로그래밍할 때 프로그래머가 사고하는 수준보다 낮다
        - doorOpen = 1; -> openDoor();
    - 직접 접근(생성자 내부만, 하위 클래스 까지만 이든 뭐든)을 어디까지 허용 할지는 개인에게 달려있다

- 간점 접근
    - 좀더 나은 유연성을 위해 메소드를 통해 상태에 접근한다
    - 접근자 메소드를 사용하면 명확성과 직접성을 희생해서 유연성을 얻을 수 있다
    - 클래스 내부에서는 직접 접근을 허락하지만 클래스 외부에서는 간접 접근을 사용하는 것을 추천한다
    - 간접 접근이 유용한 경우는 2개 이상의 데이터 간에 의존 관계가 존재하는 경우가 있다
```java
Rectangle void setWidht(int width){
    this.width = width;
    area = width * height; // 2개 이상의 데이터 간에 의존 관계가 있는 경우
}
// 이런 방식으로 해결 할 수 있지만 이것도 그닥 좋은 방법은 아니다
Widget void setBorder(int width){
    this.width = width;
    notifyListeners();
}
```

- 공용 상태 (멤버 변수)
    - 클래스의 모든 인스턴스에 적용되는 상태는 필드에 저장한다
    - 여러 연산에서 같은 데이터 요소를 사용하는 경우가 많다
      이런 경우는 클래스에 필드를 서언해서 사용 하는 것이 좋다
    - 공용 상태를 잘 만들어 놓으면 사용자는 어떻게 해야 객체의 기능을 제대로 사용 할수 있는지 쉽게 알 수 있다
    - 각 객체의 공용 상태는 모두 범위와 생명기간이 같아야 한다
    - 특정 메소드가 수행되는 도중에만 유효한 필드를 생성하고 싶을 때도 있다
      이런경우 적절한 장소에 데이터를 저장하면(인자를 사용하던지, 도우미 객체를 사용하던지) 설계를 개선할 수 있다
```java
// Point 클래스에서는 x,y값이 무조건 필요 하기 때문에 x,y를 필드로 사용 하는 것이좋다
class Point {
    int x;
    int y;
}
```

- 가변 상태
    - 같은 클래스의 인스턴스마다 다른 상태를 유지해야 할 경우 상태를 맵에 저장한다
    - 같은 객체에서도 인스턴스에 따라 각각 다른 데이터 요소를 필요로 할 때도 있다(값만 다른게 아니라 전혀 새로운 요소)
    - 가변 상태는 데이터 요소의 이름을 키로 하고 값을 데이터로 하는 맵으로 표현 된다
```java
class FlexibleObject {
    Map<String, Object> properties = new HashMap<String, Object>();
    Object getProperty(String key){
        return properties.get(key);
    }
    void setProperty(String key, Object value){
        properties.set(Key, value);
    }
}
```
    - 가변상태는 공용상태에 비해 훨씬 유연하지만, 코드 커뮤니케이션이 쉽지 않다
    - 각 필드의 상태에 따라 다른 필드를 필요로 하는 경우에는 가변 상태의 사용을 정당화할 수 있다
        - ex> A라는 필드가 참인 경우에만 B,C가 필요할 경우
    - 공용 상태를 사용하는경우, 객체의 모든 변수는 생명기간이 동일 해야한다는 원칙을 어기게 된다
    - 가능하다면 공용상태를 사용하고, 경우에 따라 어떤 필드가 필요할지 확실치 않은 경우에만 가변 상태를 사용하는 것이 좋다

- 외재 상태(Extrinsic state)    
    - 객체와 연동된 특수 상태는 상태의 사용자가 소유하는 맵에 저장 한다
    - 프로그램의 일부에서만 객체의 특정 상태를 필요로 하는 경우가 있다
        - 어떤 객체와 관련된 특수 목적 정보는 객체가 아니라 그 객체를 필요로하는 부분에 저장하는 편이 낫다
    - 외재 상태를 사용하면 객체의 복사가 어려워 진다 + 디버깅도 어려워 진다

- 변수
    - 변수는 상태 접근에 필요한 네임스페이스를 제공한다
    - 대부분의 경우에는 지역 변수를 사용하고 간간히 정적 변수와 전용 변수를 사용해서 객체 간의 의존성을 줄이는 것이 좋다
        - 변수의 종류를 줄이면, 문맥만으로도 현재 사용하는 변수가 지역 변수인지 필드인지 쉽게 구분 할 수 있다
    - 가급적 변수의 생명기간은 변수의 범위와 가까워지도록 해야 한다
    - 같은 범위에서 정의되는 변수들은 모두 같은 생명기간을 갖게 해야 한다

- 지역 변수
    - 지역 변수는 단일 범위 내에서만 유효한 상태를 저장한다
    - 

- 필드
    - 필드는 객체가 생성될 때부터 소멸 될 때까지 상태를 저장한다
- 파라미터
    - 파라미터는 메소드가 활성화된 동안 상태를 전달한다
- 수집 파라미터
    - 여러 개의 메소드를 통해 복잡한 결과를 얻기 위해 파라미터를 전달한다
- 파라미터 객체
    - 자주 사용하는 긴 파라미터 목록은 객체로 만들어서 통합한다
- 상수
    - 변하지 않는 상태는 상수로 저장한다
- 역할 제시형 작명
    - 변수 이름은 연산에서의 역할을 반영하여 짓는다
- 선언형 타입
    - 변수에 대한 일반적 타입을 선언한다
- 초기화
    - 변수 초기화는 가급적 선언적으로 한다
- 열성적 초기화
    - 인스턴스가 생성될 때 필드를 초기화한다
- 게이른 초기화
    - 초기화 비용이 높은 객체의 경우, 객체가 실제 사용되기 직전에 초기화 한다